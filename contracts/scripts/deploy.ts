import fs from "node:fs"
import path from "node:path"
import { contracts } from "@polkadot-api/descriptors"
import { type FixedSizeArray, FixedSizeBinary } from "polkadot-api"
import { deployContract } from "./utils/deploy-contract"
import { initApi } from "./utils/init-api"
import { writeAddresses } from "./utils/write-addresses"
import { ss58ToEthereum } from "@polkadot-api/sdk-ink"

/**
 * Loads the airdrop setup JSON (generated by setup_airdrop.ts).
 */
function loadAirdropSetup(): {
  root: string
  totalSupply: string
  leaves: { recipient: string; value: string; proof: string[] }[]
} {
  const setupPath = path.resolve(__dirname, "../data/airdrop/airdrop_setup.json")
  if (!fs.existsSync(setupPath)) {
    throw new Error(`Airdrop setup file not found: ${setupPath}. Run setup_airdrop.ts first.`)
  }
  return JSON.parse(fs.readFileSync(setupPath, "utf-8"))
}

const main = async () => {
  const initResult = await initApi()
  console.log("ðŸš€ API initialized:", FixedSizeBinary.fromBytes(initResult.signer.publicKey).asHex())

  // Load airdrop setup
  const setup = loadAirdropSetup()
  console.log("ðŸ“‚ Loaded airdrop setup. Root:", setup.root)

  const totalAirdropAmount = [BigInt(setup.totalSupply), 0n, 0n, 0n] as FixedSizeArray<4, bigint>

  // Deploy ERC20 assets contract
  const assetId = 80908
  const campaignEndTime = BigInt(Math.floor(Date.now() / 1000) + 30 * 60 * 60)

  const deployAssetsResult = await deployContract(initResult, "assets", contracts.assets, "new", {
    asset_id: assetId,
  })

  // Deploy MerkleAirdrop
  const deployMerkleAirdropResult = await deployContract(
    initResult,
    "merkle_airdrop",
    contracts.merkle_airdrop,
    "new",
    {
      asset_contract_address: FixedSizeBinary.fromHex(deployAssetsResult.evmAddress),
      root: FixedSizeBinary.fromHex(setup.root),
      campaign_end_time: campaignEndTime,
    },
  )

  console.log(deployMerkleAirdropResult.evmAddress, deployMerkleAirdropResult.ss58Address)

  const totalSupply = await deployAssetsResult.contract.query("Erc20::totalSupply", {
    origin: initResult.ss58Address,
  })

  console.log("Total supply: ", totalSupply)

  const balance = await deployAssetsResult.contract.query("Erc20::balanceOf", {
    origin: initResult.ss58Address,
    data: {
        account: FixedSizeBinary.fromHex(ss58ToEthereum(initResult.ss58Address).asHex())
    }
  })

  console.log("Balance: ", balance)

  // Approve tokens for funding
  console.log("ðŸ“ Approving tokens for MerkleAirdrop...")
    const approval = await deployAssetsResult.contract.send("Erc20::approve", {
    origin: initResult.ss58Address,
    data: {
      amount: totalAirdropAmount,
      spender: FixedSizeBinary.fromHex(deployMerkleAirdropResult.evmAddress),
    },
  }).signAndSubmit(initResult.signer)
  console.log("Approval: ", approval.ok, approval.dispatchError)
  console.log("âœ” Approval complete")

  const allowance = await deployAssetsResult.contract.query("Erc20::allowance", {
    origin: initResult.ss58Address,
    data: {
        spender: FixedSizeBinary.fromHex(deployMerkleAirdropResult.evmAddress),
        owner: FixedSizeBinary.fromHex(ss58ToEthereum(initResult.ss58Address).asHex())
    }
  })

  console.log("Allowance: ", allowance)

  // Fund the MerkleAirdrop
  console.log("ðŸ’° Funding MerkleAirdrop with", setup.totalSupply, "tokens...")
  const fund = await deployMerkleAirdropResult.contract
    .send("fund", {
      origin: initResult.ss58Address,
      data: {
        total_airdrop_amount: totalAirdropAmount,
      },
    })
    .signAndSubmit(initResult.signer)
    console.log("Fund: ", fund.ok, fund.dispatchError)
  console.log("âœ” Funding complete")

  console.log("ðŸ’° Claiming ", setup.leaves[0]?.value, "airdrop tokens...")
  deployMerkleAirdropResult.contract
    .send("claim", {
      origin: initResult.ss58Address,
      data: {
        index: 0n,
        proof: setup.leaves[0]?.proof.map((proof) =>
          FixedSizeBinary.fromHex(proof),
        ) as FixedSizeBinary<32>[],
        value: [BigInt(setup.leaves[0]?.value!), 0n, 0n, 0n],
      },
    })
    .signAndSubmit(initResult.signer)
    .then((tx) => {
      if (!tx.ok) throw new Error("Failed to send `claim` transaction", { cause: tx.dispatchError })
    }).catch(error => console.error(`Error: ${error}`))
    console.log("âœ” Claiming complete")

  console.log("ðŸ’° Claiming ", setup.leaves[0]?.value, "airdrop tokens...")
    deployMerkleAirdropResult.contract
    .send("claim", {
      origin: initResult.ss58Address,
      data: {
        index: 0n,
        proof: setup.leaves[0]?.proof.map((proof) =>
          FixedSizeBinary.fromHex(proof),
        ) as FixedSizeBinary<32>[],
        value: [BigInt(setup.leaves[0]?.value!), 0n, 0n, 0n],
      },
    })
    .signAndSubmit(initResult.signer)
    .then((tx) => {
      if (!tx.ok) throw new Error("Failed to send `claim` transaction", { cause: tx.dispatchError })
    }).catch(error => console.error(`Error: ${error}`))
    console.log("âœ” Claiming complete")

  await writeAddresses({ assets: deployAssetsResult })
  await writeAddresses({ merkle_airdrop: deployMerkleAirdropResult })
}

main()
  .catch((error) => {
    console.error(error)
    process.exit(1)
  })
  .finally(() => process.exit(0))
