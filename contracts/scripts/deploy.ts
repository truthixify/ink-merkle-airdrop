import fs from "node:fs"
import path from "node:path"
import { contracts } from "@polkadot-api/descriptors"
import { FixedSizeBinary } from "polkadot-api"
import { deployContract } from "./utils/deploy-contract"
import { initApi } from "./utils/init-api"
import { writeAddresses } from "./utils/write-addresses"

/**
 * Reads the code hash from the compiled contract JSON file.
 * @param filePath Path to the `.contract` JSON artifact.
 * @returns The contract's code hash as a hex string.
 */
function readCodeHash(filePath: string): string {
  const artifact = JSON.parse(fs.readFileSync(filePath, "utf-8"))
  if (!artifact?.source?.hash) {
    throw new Error(`No source.hash found in ${filePath}`)
  }
  return artifact.source.hash
}

/**
 * Loads the airdrop setup JSON (generated by setup_airdrop.ts).
 */
function loadAirdropSetup(): {
  root: string
  totalSupply: string
  leaves: { recipient: string; value: string; proof: string[] }[]
} {
  const setupPath = path.resolve(__dirname, "../data/airdrop/airdrop_setup.json")
  if (!fs.existsSync(setupPath)) {
    throw new Error(`Airdrop setup file not found: ${setupPath}. Run setup_airdrop.ts first.`)
  }
  return JSON.parse(fs.readFileSync(setupPath, "utf-8"))
}

/**
 * This script initializes the Polkadot API client and deploys the contract
 * using the provided utilities under './utils'.
 *
 * @options
 *  Environment variables:
 *    CHAIN         - Target chain to deploy the contract to (must be initialized with `bunx papi add <chain>`). Default: `dev`
 *    ACCOUNT_URI   - Account to deploy the contract from. If not set, uses `.env.{CHAIN}` or defaults to `//Alice`
 *    DIR           - Directory to write the contract addresses to. Default: `./deployments`
 *
 * @example
 * CHAIN=dev bun run deploy.ts
 */
const main = async () => {
  const initResult = await initApi()

  // Deploy ERC20 assets contract
  const assetsArtifactPath = path.resolve(__dirname, "../deployments/assets/assets.json")
  const assetsCodeHash = readCodeHash(assetsArtifactPath)
  const assetId = 1337
  const campaignEndTime = BigInt(Math.floor(Date.now() / 1000) + 30 * 60 * 60)

  const deployAssetsResult = await deployContract(initResult, "assets", contracts.assets, "new", {
    asset_id: assetId,
  })
  console.log("deplio", deployAssetsResult)

  await writeAddresses({ assets: deployAssetsResult })

  // Load airdrop setup (Merkle root, totalSupply, leaves)
  const setup = loadAirdropSetup()

  // Deploy MerkleAirdrop with root + supply
  const deployMerkleAirdropResult = await deployContract(
    initResult,
    "merkle_airdrop",
    contracts.merkle_airdrop,
    "new",
    {
      asset_id: assetId,
      asset_contract_code_hash: FixedSizeBinary.fromHex(assetsCodeHash),
      root: FixedSizeBinary.fromHex(setup.root),
      campaign_end_time: campaignEndTime,
      total_airdrop_amount: [BigInt(setup.totalSupply), 0n, 0n, 0n], // scale to U256 tuple
    },
  )

  await writeAddresses({ merkle_airdrop: deployMerkleAirdropResult })
}

main()
  .catch((error) => {
    console.error(error)
    process.exit(1)
  })
  .finally(() => process.exit(0))
